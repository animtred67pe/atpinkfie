<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>PinkFie Video Decoder</title>
		<style>
			body {
				background: #111;
				color: #fff;
				font-family: monospace;
			}
			a {
				color: #fff;
			}
			.pinkfie-video-player {
				margin: 10px;
				display: inline-block;
				border: 4px solid #888;
				border-radius: 12px;
				padding: 10px;
			}
		</style>
	</head>
	<body>
		<a href="./" style="position: fixed; top: 10px; right: 10px;">back</a>
		<div class="app">
			<a href="#" id="clickswfe">SWF Examples</a>
			<div id="swfeArea"></div>
			<br>
			<a href="#" id="loadswffile">Open .swf</a>
			<h2 id="ggtitle5"></h2>
			<div id="demo"></div>
			<div id="swfvideos"></div>
		</div>
		<a href="https://animtred67pe.github.io/introtry9/" title="Go To SEATGERY Website" style="position:fixed; bottom: 10px; right: 10px; width: 50px; height: 50px;background-size: 50px; background-image: url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2250%22%20height%3D%2250%22%20viewBox%3D%220%2C0%2C50%2C50%22%3E%3Cg%20transform%3D%22translate%28-215%2C-155.2%29%22%3E%3Cg%20stroke%3D%22%23ffffff%22%3E%3Cpath%20d%3D%22M215.75%2C179.95c0%2C-13.3%2010.8%2C-24%2024%2C-24c13.3%2C0%2024%2C10.8%2024%2C24c0%2C13.3%20-10.8%2C24%20-24%2C24c-13.3%2C0%20-24%2C-10.8%20-24%2C-24z%22%20fill-opacity%3D%220.5%22%20fill%3D%22%23000000%22%20stroke-width%3D%221.5%22%20stroke-linecap%3D%22butt%22%2F%3E%3Cpath%20d%3D%22M234.60%2C173.15c0%2C0%20-2.76%2C-1.04%20-4.9%2C-0.49c-1.97%2C0.5%20-3.11%2C1.94%20-2.75%2C3.92c0.35%2C1.97%201.94%2C2.86%204.08%2C3.44c2.15%2C0.58%205.84%2C2.47%203.42%2C5.76c-1.6%2C2.17%20-8.14%2C0.81%20-8.14%2C0.81%22%20fill%3D%22none%22%20stroke-width%3D%224%22%20stroke-linecap%3D%22round%22%2F%3E%3Cpath%20d%3D%22M252.77%2C172.91c0%2C0%20-5.09%2C-1.3%20-8.56%2C0.76c-4.54%2C2.82%20-3.99%2C10.71%200.58%2C12.81c3.47%2C1.59%208.52%2C0.24%208.52%2C0.24l-0.04%2C-6.14l-4.16%2C-0.04%22%20fill%3D%22none%22%20stroke-width%3D%224%22%20stroke-linecap%3D%22round%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E);"></a>
		<script src="pinkfie.js"></script>
		<script src="common.js"></script>
		<script src="pinkfie_logo.js"></script>
		<script src="swfexamples.js"></script>
		<script>
			const ZLib = (function() {const A = {key: new Uint16Array([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]), value: new Uint16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])}, S = {key: new Uint16Array([7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9]), value: new Uint16Array([256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 280, 281, 282, 283, 284, 285, 286, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255])};const Q = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), W = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99]), E = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), R = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), T = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]);class B {constructor(_, a = 0, b = 0) {this.data = _, this.byte_offset = a, this.bit_offset = b, this.bit_buffer = null} readSubArray(n) {var a = this.data.subarray(this.byte_offset, this.byte_offset + n); return this.byte_offset += n, a;} readUint8() {return this.data[this.byte_offset++]} readUint16be() {var a = (this.data[this.byte_offset + 1] << 8) + this.data[this.byte_offset]; return this.byte_offset += 2, a} readUB(n) {let z = 0; for (let i = 0; i < n; i++) {if (this.bit_offset === 8) this.bit_buffer = this.data[this.byte_offset++], this.bit_offset = 0;z |= (this.bit_buffer & (1 << this.bit_offset++) ? 1 : 0) << i};return z}};const D = function (_) {let r = Math.max.apply(null, _);const p = _.length, c = new Uint8Array(r);let i = p, j = 0;while (i--) j = _[i], c[j] += (j > 0);let m = 0, o = 0;const g = new Uint16Array(r + 1);for (i = 0; i < r; ) m = (m + c[i++]) << 1, g[i] = m | 0, o = Math.max(o, m);const n = o + p, k = new Uint16Array(n), v = new Uint16Array(n);for (i = 0; i < p; i++) {if (j = _[i], j) {const u = g[j]; k[u] = j, v[u] = i, g[j] = (u + 1) | 0}};return {key: k, value: v}};const F = function (x, y, z) {let a = 0, b = 0;while (true) {b = (b << 1) | x.readUB(1); a++; if (y[b] === a) return z[b];}};return {decompress: function (_, n, v) {var a = v || 0; const o = new Uint8Array(n), br = new B(new Uint8Array(_), a + 2, 8), h = new Uint8Array(19); var y = 0, i = 0, b = 0, f = 0; while (!f) {f = br.readUB(1); let u = br.readUB(2), j = null, l = null; switch (u) {case 0: br.bit_offset = 8, br.bit_buffer = null, b = br.readUint16be(), br.byte_offset += 2, o.set(br.readSubArray(b), a), a += b; break; default: switch (u) {case 1: j = A, l = S; break; default: const q = br.readUB(5) + 257, w = br.readUB(5) + 1, e = br.readUB(4) + 4; for (i = 0; i < e; i++) h[Q[i]] = br.readUB(3); const s = D(h); h.fill(0); const c = q + w, d = new Uint8Array(c); let z = 0, t = 0; while (t < c) {y = F(br, s.key, s.value);switch (y) {case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15: d[t++] = y, z = y; break; case 16: i = br.readUB(2) + 3, d.fill(z, t, t + i), t += i; break; case 17: i = br.readUB(3) + 3, t += i; break; case 18: i = br.readUB(7) + 11, t += i; break;}};j = D(d.subarray(q)), l = D(d.subarray(0, q))};y = 0;while (true) {if (y = 0 | F(br, l.key, l.value), 256 === y) break;if (y < 256) {o[a++] = y} else {const z = (y - 257) | 0; b = (E[z] + br.readUB(W[z])) | 0; const x = F(br, j.key, j.value); i = (a - ((T[x] + br.readUB(R[x])) | 0)) | 0; while (b--) o[a++] = o[i++];}}}} return o.buffer}}}());
			const Bitmap = function(width, height, format, data) {
				this.width = width;
				this.height = height;
				this.format = format;
				this.data = data;
			}
			Bitmap.prototype.toRGBA = function() {
				var width = this.width;
				var height = this.height;
				switch (this.format) {
					case "yuv420p":
					case "yuva420p":
						var isAlpha = this.format == "yuva420p";
						var chroma_width = (((width + 1) / 2) | 0);
						var chroma_height = (((height + 1) / 2) | 0);
						var yuv = this.data;
						var data = new Uint8Array((width * height) * 4);
						var yOffset = 0;
						var uOffset = width * height;
						var vOffset = uOffset + (chroma_width * chroma_height);
						var aOffset = uOffset + (chroma_width * chroma_height) + (chroma_width * chroma_height);
						for (var h = 0; h < height; h++) {
							for (var w = 0; w < width; w++) {
								var ypos = w + h * width + yOffset;
								var upos = (w >> 1) + (h >> 1) * chroma_width + (uOffset);
								var vpos = (w >> 1) + (h >> 1) * chroma_width + (vOffset);
								var Y = yuv[ypos] - 16;
								var U = yuv[upos] - 128;
								var V = yuv[vpos] - 128;
								var R = (1.164 * Y + 1.596 * V);
								var G = (1.164 * Y - 0.813 * V - 0.391 * U);
								var B = (1.164 * Y + 2.018 * U);
								var outputData_pos = w * 4 + width * h * 4;
								data[0 + outputData_pos] = Math.max(Math.min(R, 255), 0);
								data[1 + outputData_pos] = Math.max(Math.min(G, 255), 0);
								data[2 + outputData_pos] = Math.max(Math.min(B, 255), 0);
								data[3 + outputData_pos] = isAlpha ? yuv[w + h * width + aOffset] : 255;
							}
						}
						this.data = data;
						break;
				}
			}
			const H263Decoder = function (deblocking) {
				this.state = new AT_H263_Decoder.H263State({
					sorensonSpark: true,
					useScalabilityMode: false,
				});
				this.deblocking = deblocking;
			};
			H263Decoder.prototype.preloadFrame = function (encodedFrame) {
				var reader = new AT_H263_Decoder.H263Reader(new Uint8Array(encodedFrame.data));
				let picture = this.state.parsePicture(reader, null);
				switch(picture.picture_type.getType()) {
					case "IFrame":
						return false;
					case "PFrame":
					case "DisposablePFrame":
						return true;
					default:
						throw new Error("Invalid picture type code: " + picture.picture_type.type);
				}
			};
			H263Decoder.prototype.decodeFrame = function (encodedFrame) {
				var reader = new AT_H263_Decoder.H263Reader(new Uint8Array(encodedFrame.data));
				this.state.decodeNextPicture(reader);
				var picture = this.state.getLastPicture();
				let [y, b, r] = picture.as_yuv();
				let [width, height] = picture.format.intoWidthAndHeight();
				var yuv = new Uint8Array(y.length + b.length + r.length);
				yuv.set(y, 0);
				yuv.set(b, y.length);
				yuv.set(r, y.length + b.length);
				return new Bitmap(width, height, "yuv420p", yuv);
			};

			const ByteReader = function(data) {
				this.data = new Uint8Array(data);
				this.offest = 0;
			}
			ByteReader.prototype.readByte = function() {
				if (this.offest >= this.data.length) 
					throw new Error("Unexpected end of file");
				return this.data[this.offest++];
			}
			ByteReader.prototype.readUint16be = function() {
				var byte1 = this.readByte();
				var byte2 = this.readByte();
				return (byte1 << 8) | byte2;
			}
			ByteReader.prototype.readBuf = function(length) {
				if ((this.offest + length) > this.data.length) 
					throw new Error("Unexpected end of file");
				var result = this.data.slice(this.offest, this.offest + length);
				this.offest += length;
				return result;
			}
			
			const ScreenVideoDecoder = function (size, version) {
				this.version = version;
				this.w = 0;
				this.h = 0;
				this.blockW = 0;
				this.blockH = 0;
				this.width = size[0];
				this.height = size[1];
				this.lastFrame = null;
			};
			ScreenVideoDecoder.prototype.preloadFrame = function (encodedFrame) {
				var byte_input = new ByteReader(encodedFrame.data);
				var type = byte_input.readByte() >> 4;
				switch (type) {
					case 1:
						return 0;
					case 2:
						return 1;
					default:
						throw new Error("Invalid frame type: " + type);
				}
			}
			ScreenVideoDecoder.prototype.fillBlock = function (a, b, x, y, cur_w, cur_h) {
				for (let _y = 0; _y < cur_h; _y++) {
					for (let _x = 0; _x < cur_w; _x++) {
						var rgbIdx = (_x + (cur_w * ((cur_h - _y) - 1))) * 3;
						var idx = ((_x + x) + (this.w * (_y + y))) * 4;
						a[idx] = b[rgbIdx + 2];
						a[idx + 1] = b[rgbIdx + 1];
						a[idx + 2] = b[rgbIdx];
						a[idx + 3] = 255;
					}
				}
			}
			ScreenVideoDecoder.prototype.decodeFrame = function (encodedFrame) {
				var byte_input = new ByteReader(encodedFrame.data);
				var isKeyframe = byte_input.readByte() >> 4 == 1;
				if (!isKeyframe && !this.lastFrame) 
					throw new Error("Missing reference frame");
				var hdr0 = byte_input.readUint16be();
				var blk_w = ((hdr0 >> 12) * 16) + 16;
				var w = hdr0 & 0xFFF;
				var hdr1 = byte_input.readUint16be();
				var blk_h = ((hdr1 >> 12) * 16) + 16;
				var h = hdr1 & 0xFFF;
				if (this.w != w || this.h != h || this.blockW != blk_w || this.blockH != blk_h) {
					this.w = w;
					this.h = h;
					this.blockW = blk_w;
					this.blockH = blk_h;
					this.lastFrame = new Uint8Array(w * h * 4);
				}
				var rgba = this.lastFrame;
				var is_intra = true;
				for (let yc = 0; yc < this.h; yc += this.blockH) {
					let cur_h = Math.min((this.h - yc), this.blockH);
					for (let xc = 0; xc < this.w; xc += this.blockW) {
						let cur_w = Math.min((this.w - xc), this.blockW);
						var dataSize = byte_input.readUint16be();
						if (dataSize > 0) this.fillBlock(rgba, new Uint8Array(ZLib.decompress(byte_input.readBuf(dataSize).buffer, (cur_w * cur_h) * 3)), xc, (this.h - yc) - cur_h, cur_w, cur_h);
						else is_intra = false;
					}
				}
				if (is_intra != isKeyframe) 
					throw new Error("Not all blocks were updated by a supposed keyframe");
				return new Bitmap(w, h, "rgba", rgba);
			};

			function crop(data, width, to_width, to_height) {
				let height = (data.length / width) | 0;
				if (width > to_width) {
					let new_width = to_width;
					let new_height = Math.min(height, to_height);
					let _data = new Uint8Array(new_width * new_height);
					for (let row = 0; row < new_height; row++) {
						_data.set(data.subarray(row * width, (row * width + new_width)), row * new_width);
					}
					return _data;
				} else {
					return data.subarray(0, width * Math.min(height, to_height));
				}
			}

			const VP6Decoder = function (size, withAlpha) {
				this.width = size[0];
				this.height = size[1];
				this.withAlpha = withAlpha;
				this.decoder = new AT_NIHAV_VP6_Decoder.VP56Decoder(6, withAlpha, true);
				this.support = new AT_NIHAV_VP6_Decoder.NADecoderSupport();
				this.bitreader = new AT_NIHAV_VP6_Decoder.VP6BR();
				this.initCalled = false;
				this.lastFrame = null; // NABufferRef NAVideoBuffer
			};
			VP6Decoder.prototype.preloadFrame = function (encodedFrame) {
				return new Uint8Array(encodedFrame.data)[this.withAlpha ? 3 : 0] & 128;
			};
			VP6Decoder.prototype.decodeFrame = function (encodedFrame) {
				var videoData = new Uint8Array(encodedFrame.data);
				if (!this.initCalled) {
					var bool_coder = new AT_NIHAV_VP6_Decoder.BoolCoder(videoData.subarray(this.withAlpha ? 3 : 0));
					let header = this.bitreader.parseHeader(bool_coder);
					let video_info = new AT_NIHAV_VP6_Decoder.NAVideoInfo(header.disp_w * 16, header.disp_h * 16, true, this.withAlpha ? AT_NIHAV_VP6_Decoder.VP_YUVA420_FORMAT : AT_NIHAV_VP6_Decoder.YUV420_FORMAT);
					this.decoder.init(this.support, video_info);
					this.initCalled = true;
				}
				let decoded;
				var frame = null;
				decoded = this.decoder.decode_frame(this.support, videoData, this.bitreader);
				frame = decoded[0].value;
				let yuv = frame.get_data();
				let [width, height] = frame.get_dimensions(0);
				let [chroma_width, chroma_height] = frame.get_dimensions(1);
				let offsets = [
					frame.get_offset(0),
					frame.get_offset(1),
					frame.get_offset(2)
				];
				if ((width < this.width) || (height < this.height)) {
					console.log("A VP6 video frame is smaller than the bounds of the stream it belongs in. This is not supported.");
				}
				let y = yuv.subarray(offsets[0], offsets[0] + width * height);
				let u = yuv.subarray(offsets[1], offsets[1] + chroma_width * chroma_height);
				let v = yuv.subarray(offsets[2], offsets[2] + chroma_width * chroma_height);
				let _y = crop(y, width, this.width, this.height);
				let _u = crop(u, chroma_width, ((this.width + 1) / 2) | 0, ((this.height + 1) / 2) | 0);
				let _v = crop(v, chroma_width, ((this.width + 1) / 2) | 0, ((this.height + 1) / 2) | 0);
				width = this.width;
				height = this.height;
				if (this.withAlpha) {
					let [alpha_width, alpha_height] = frame.get_dimensions(3);
					let alpha_offset = frame.get_offset(3);
					let alpha = yuv.subarray(alpha_offset, alpha_offset + alpha_width * alpha_height);
					let a = crop(alpha, alpha_width, this.width, this.height);
					let yuvData = new Uint8Array(_y.length + _u.length + _v.length + a.length);
					yuvData.set(_y, 0);
					yuvData.set(_u, _y.length);
					yuvData.set(_v, _y.length + _u.length);
					yuvData.set(a, _y.length + _u.length + _v.length);
					return new Bitmap(width, height, "yuva420p", yuvData);
				} else {
					let yuvData = new Uint8Array(_y.length + _u.length + _v.length);
					yuvData.set(_y, 0);
					yuvData.set(_u, _y.length);
					yuvData.set(_v, _y.length + _u.length);
					return new Bitmap(width, height, "yuv420p", yuvData);
				}
			};

			var swfvideos = document.getElementById("swfvideos");

			var resurtVideos = [];
			var videos = [];

			var resultswf = null;
			var SwfTag = PinkFie.SwfTag;
			var AT_H263_Decoder = PinkFie.AT_H263_Decoder;
			var AT_NIHAV_VP6_Decoder = PinkFie.AT_NIHAV_VP6_Decoder;
			var demo = document.getElementById("demo");
			var ggtitle5 = document.getElementById("ggtitle5");

			function createDecoder(_num_frames, size, codec, filter) {
				var decoder;
				switch (codec) {
					case "none":
						decoder = null;
						break;
					case "H263":
						decoder = new H263Decoder(filter);
						break;
					case "ScreenVideo":
						decoder = new ScreenVideoDecoder(size, false);
						break;
					case "Vp6":
						decoder = new VP6Decoder(size, false);
						break;
					case "Vp6WithAlpha":
						decoder = new VP6Decoder(size, true);
						break;
					default:
						console.log("Unsupported video codec type " + codec);
				}
				return decoder;
			}

			const VideoPlayer = function(data, frameRate) {
				this.isPlaying = false;
				this.interval = null;
				this.frame = -1;
				this.data = data;
				this.width = data.width;
				this.height = data.height;
				this.frames = data.frames;
				this.frameRate = frameRate;
				this.decoder = createDecoder(0, [data.width, data.height], data.codec, data.deblocking);
				this.keyframes = [];
				this.root = document.createElement("div");
				this.root.style.position = "relative";
				this.canvas = document.createElement("canvas");
				this.canvas.style.position = "absolute";
				this.canvas.style.top = "0";
				this.canvas.style.left = "0";
				this.ctx = this.canvas.getContext("2d");

				this.controls = document.createElement("div");
				this.controls.style.background = "rgba(0,0,0,0.5)";
				this.controls.style.position = "absolute";
				this.controls.style.bottom = "0";
				this.controls.style.left = "0";
				this.controls.style.width = "100%";
				this.controls.style.height = "25px";
				this.controls.style.overflow = "hidden";

				if (this.frames.length <= 1) {
					this.controls.style.display = "none";
				}

				this.controlPlayPause = document.createElement("button");
				this.controlPlayPause.textContent = "Play";

				this.controlPlayPause.onclick = () => {
					if (this.isPlaying) {
						this.pause();
					} else {
						this.play();
					}
				}

				this.controlLabel = document.createElement("label");
				this.controlLabel.textContent = "1/1";
				this.controlLabel.style.color = "#fff";

				this.controlRange = document.createElement("input");
				this.controlRange.type = "range";
				this.controlRange.min = "0";
				this.controlRange.max = Math.max(this.frames.length - 1, 1);
				this.controlRange.value = "0";

				this.controlRange.addEventListener("input", () => {
					this.seek(+this.controlRange.value);
				});

				this.controls.appendChild(this.controlPlayPause);
				this.controls.appendChild(this.controlLabel);
				this.controls.appendChild(this.controlRange);

				this.root.appendChild(this.canvas);
				this.root.appendChild(this.controls);
				this.resize(this.width, this.height);
			}
			VideoPlayer.prototype.resize = function(w, h) {
				this.width = w;
				this.height = h;
				this.root.style.width = w + "px";
				this.root.style.height = h + "px";
				this.controlRange.style.width = "50%";
				this.canvas.width = w;
				this.canvas.height = h;
			}
			VideoPlayer.prototype.init = function() {
				for (var i = 0; i < this.frames.length; i++) {
					var frame = this.frames[i];
					if (frame) {
						this.keyframes[i] = this.decoder.preloadFrame({data: frame});
					}
				}
				this.seek(0);
			}
			VideoPlayer.prototype.play = function() {
				if (!this.isPlaying) {
					this.controlPlayPause.textContent = "Pause";
					this.isPlaying = true;
					this.interval = setInterval(this.step.bind(this), this.frameRate);
				}
			}
			VideoPlayer.prototype.pause = function() {
				if (this.isPlaying) {
					this.controlPlayPause.textContent = "Play";
					this.isPlaying = false;
					clearInterval(this.interval);
					this.interval = null;
				}
			}
			VideoPlayer.prototype.step = function() {
				this.seek((this.frame + 1) % this.frames.length);
			}
			VideoPlayer.prototype.seek = function(frame_id) {

				let last_frame = this.frame;

				if (last_frame == frame_id) return;

				let is_ordered_seek = (frame_id == 0) || frame_id == (last_frame + 1);

				let sweep_from = frame_id;
				if (!is_ordered_seek) {
					var keyframes = this.keyframes;
					for (let i = frame_id; i >= 0; i--) {
						if (i in keyframes) {
							const isKeyframe = keyframes[i];
							if (!isKeyframe) {
								sweep_from = i;
								break;
							}
						}
					}
					if (last_frame !== null) {
						if (frame_id > last_frame) {
							sweep_from = Math.max(sweep_from, last_frame + 1);
						}
					}
				}
				
				var fr = sweep_from;
				while (fr <= frame_id) {
					this.seek_internal(fr);
					fr++;
				}
			}
			VideoPlayer.prototype.seek_internal = function(frame) {
				this.frame = frame;
				this.controlRange.value = Math.min(frame, this.frames.length);
				this.controlLabel.textContent = (frame + 1) + "/" + this.frames.length;
				var frameData = this.frames[frame];
				if (frameData) {
					var data;
					try {
						data = this.decoder.decodeFrame({data: frameData});
					} catch(e) {
						console.log(e);
						return;
					}
					data.toRGBA();
					var imageData = new ImageData(this.data.width, this.data.height);
					imageData.data.set(data.data, 0);
					this.ctx.putImageData(imageData, 0, 0);
				}
			}

			var swfeArea = document.getElementById('swfeArea');

			var sef = new SWFE(pinkfieSampleSWF, "Videos Codec:");
			sef.root.style.display = "none";
			swfeArea.appendChild(sef.root);

			clickswfe.onclick = function() {
				if (sef.root.style.display == "none") {
					sef.root.style.display = "";
					sef.load();
				} else {
					sef.root.style.display = "none";
				}
			}
			sef.onclick = function(gd) {
				sef.root.style.display = "none";
				loadSampleSWF(gd);
			}

			function slowswf() {
				demo.innerHTML = "<br>preloading videos";

				setTimeout(function() {
					function dfgfdD(tags) {
						for (var i = 0; i < tags.length; i++) {
							var rg = tags[i];
							if (rg.tagcode == 60) {
								videos[rg.id] = {
									frames: [],
									id: rg.id,
									width: rg.width,
									height: rg.height,
									codec: rg.codec,
									deblocking: rg.deblocking,
								};
							} else if (rg.tagcode == 61) {
								videos[rg.streamId].frames[rg.frameNum] = rg.videoData;
							} else if (rg.tagcode == 39) {
								dfgfdD(rg.tags);
							}
						}	
					}
					dfgfdD(resultswf.tags);
					for (var i = 0; i < videos.length; i++) {
						var vid = videos[i];
						if (vid) {
							var videoplayer = new VideoPlayer(vid, 1000 / (resultswf ? resultswf.movieInfo.frameRate : 10));
							videoplayer.init();
							var gfd = document.createElement("div");
							gfd.className = "pinkfie-video-player";
							var gfd3 = document.createElement("h3");
							gfd3.textContent = "Video ID: " + vid.id + " Codec: " + vid.codec;
							gfd3.style.margin = "2px";
							var gfd2 = document.createElement("p");
							gfd2.textContent = "deblocking: " + vid.deblocking + " resolution " + vid.width + "x" + vid.height;
							gfd2.style.margin = "2px";
							gfd.appendChild(gfd3);
							gfd.appendChild(gfd2);
							gfd.appendChild(videoplayer.root);
							swfvideos.appendChild(gfd);
							vid.root = gfd;
							vid.player = videoplayer;
						}
					}
					demo.innerHTML = "";
				}, 100)

				
			}

			function _reset() {
				for (var i = 0; i < videos.length; i++) {
					var vgf = videos[i];
					if (vgf) {
						vgf.player.pause();
						swfvideos.removeChild(vgf.root);
					}
				}
				videos = [];
			}

			function loadSwfBuffer(buffer) {
				var swfparser = new SwfTag(buffer);
				swfparser.onprogress = function(fs) {
					if (fs[0]) {
						demo.innerHTML = "<br>decoding tags " + Math.round(fs[1] * 100) + "%";
					} else {
						demo.innerHTML = "<br>compressed swf " + Math.round(fs[1] * 100) + "%";
					}
				}
				swfparser.onload = function() {
					slowswf();
				}
				swfparser.onerror = function(e) {
				}
				swfparser.onstartmovie = function(header, movieInfo, tagCallback) {
					function j(s, h) {
						var g = [];
						s._ontag = function(o) {
							g.push(o);
							if (o.tagcode == 39) {
								j(o.tagCallback, function(b) {
									o.tags = b;
								});
							};
							return null;
						}
						s._onend = function() {
							h(g);
						}
					}
					resultswf = {};
					resultswf.header = header;
					resultswf.movieInfo = movieInfo;
					j(tagCallback, function(q) {
						resultswf.tags = q;
					});
				}
				swfparser.load();
			}

			function fetchSwfMd5(md5, callback, callbackProgress) {
				var xhr = new XMLHttpRequest();
				xhr.onload = function () {
					callback(new Uint8Array(xhr.response.slice(0x2c)));
				};
				xhr.onprogress = function (e) {
					if (callbackProgress) callbackProgress(e.loaded / e.total);
				};
				xhr.onerror = function () {
					callback(null);
				};
				xhr.responseType = "arraybuffer";
				xhr.open("GET", "https://assets.scratch.mit.edu/internalapi/asset/" + md5 + ".wav/get/");
				xhr.send();
			}
			function fetchSwfUrl(url, callback, callbackProgress) {
				var xhr = new XMLHttpRequest();
				if (Array.isArray(url)) {
					var result = [];
					var id_md5 = 0;
					function _excgfd() {
						if (result.length > 1) {
							var len = 0;
							for (var i = 0; i < result.length; i++) {
								len += result[i].length;
							}
							var res = new Uint8Array(len);
							var offest = 0;
							for (var i = 0; i < result.length; i++) {
								res.set(result[i], offest);
								offest += result[i].length;
							}
							callback(new Blob([res]), null);
						} else {
							callback(new Blob([result[0]]), null);
						}
					}
					function _next() {
						fetchSwfMd5(url[id_md5], function(res) {
							if (!res) {
								callback(null, "failed md5");
								return;
							}
							id_md5++;
							result.push(res);
							if (id_md5 >= url.length) {
								_excgfd();
							} else {
								_next();
							}
						}, function(_p) {
							if (callbackProgress) callbackProgress((id_md5 / url.length) + (_p / url.length));
						});
					}
					_next();
				} else {
					xhr.onload = function () {
						if (xhr.status !== 200) {
							callback(null, xhr.status || xhr.statusText);
						} else {
							var dat = new Uint8Array(xhr.response);
							callback(new Blob([dat]), null);
						}
					};
					xhr.onprogress = function (e) {
						if (callbackProgress) callbackProgress(e.loaded / e.total);
					};
					xhr.onerror = function () {
						callback(null, "unknown");
					};
					xhr.responseType = "arraybuffer";
					xhr.open("GET", url);
					xhr.send();
				}
			}

			function loadSwfURL(array) {
				demo.innerHTML = "<br>loading swf url";
				fetchSwfUrl(array, function(a) {
					var reader = new FileReader();
					reader.onload = function(e) {
						loadSwfBuffer(e.target.result);
					};
					reader.readAsArrayBuffer(a);
				}, function(e) {
					demo.innerHTML = "<br>loading swf url " + Math.round(e * 100) + "%";
				})
			}

			function loadSampleSWF(infoSample) {
				_reset();
				var name = infoSample.name;
				ggtitle5.textContent = name;
				if (infoSample.md5) {
					loadSwfURL(infoSample.md5.split("_"));
				}
			}

			var loadprojectfile = document.getElementById('loadswffile');
			loadprojectfile.onclick = function () {
				var sa = document.createElement('input');
				sa.type = 'file';
				sa.accept = '.swf';

				sa.addEventListener('change', function (e) {
					var file = e.target.files[0];
					if (!file) 
						return;

					ggtitle5.textContent = file.name || "";
					_reset();
					demo.innerHTML = "<br>opening swf file";
					var reader = new FileReader();
					reader.onload = function(e) {
						loadSwfBuffer(e.target.result);
					};
					reader.readAsArrayBuffer(file);
				}, false);
				sa.click();
			}
				
			if (Common.swfexamples) {
				sef.root.style.display = "";
				sef.load();
			}
		</script>
	</body>
</html>